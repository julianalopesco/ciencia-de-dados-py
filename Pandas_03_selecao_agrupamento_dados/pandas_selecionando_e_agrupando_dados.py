# -*- coding: utf-8 -*-
"""pandas_selecionando_e_agrupando_dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eG_4R4z7uYYzGb8do-FOlrVvWtTWbVIv
"""

#lendo dados do google drive
import pandas as pd

emissoes_gases = pd.read_excel('/content/drive/MyDrive/Ciência de dados com Python - Alura/ciencia-de-dados-py/Pandas_03/1-SEEG10_GERAL-BR_UF_2022.10.27-FINAL-SITE.xlsx', sheet_name = 'GEE Estados')

#01 - CONHECENDO OS DADOS

emissoes_gases

#exibindo as colunas
emissoes_gases.info()

#ajustando a base de dados
emissoes_gases['Emissão / Remoção / Bunker'].unique()

#filtrando na base de dados
(emissoes_gases['Emissão / Remoção / Bunker'] == 'Remoção NCI') |(emissoes_gases['Emissão / Remoção / Bunker'] == 'Remoção') #filtro de comparação booleana

emissoes_gases[emissoes_gases['Emissão / Remoção / Bunker'].isin(['Remoção NCI', 'Remoção'])] #método para selecionar valores na mesma coluna

#selecionando somente os dados das colunas numericas
emissoes_gases.loc[emissoes_gases['Emissão / Remoção / Bunker'].isin(['Remoção NCI', 'Remoção']),1970:2021]

#verificando o max das colunas
emissoes_gases.loc[emissoes_gases['Emissão / Remoção / Bunker'].isin(['Remoção NCI', 'Remoção']),1970:2021].max()

#identificando se algum valor do tipo bunker corresponde a alguma emisssão de estado
emissoes_gases.loc[emissoes_gases['Emissão / Remoção / Bunker'] =='Bunker', 'Estado'].unique()

#substituindo a base de dados, removendo as remissões
emissoes_gases = emissoes_gases[emissoes_gases['Emissão / Remoção / Bunker'] == 'Emissão']
emissoes_gases

#removendo uma coluna da base
emissoes_gases = emissoes_gases.drop(columns = 'Emissão / Remoção / Bunker')
emissoes_gases

#para selecionar os dados que não são da categoria 'Emissão' e armazená-los
#emissoes_gases[emissoes_gases['Emissão / Remoção / Bunker'] != 'Emissão']

#filtrando por estado:
#emissoes_gases[emissoes_gases['Estado'].isin(['PR', 'RS', 'SC'])]

#02 - AGRUPAMENTO DE DADOS

#agrupando colunas numéricas
emissoes_gases.loc[:,'Nível 1 - Setor': 'Produto'].columns

#listando as colunas que serão mantidas
colunas_info = list (emissoes_gases.loc[:,'Nível 1 - Setor': 'Produto'].columns)
colunas_info

#aplicando nas colunas de anos
emissoes_gases.loc[:,1970:2021].columns

#armazenando em uma nova variavel, transformando em lista
colunas_emissao = list(emissoes_gases.loc[:,1970:2021].columns)
colunas_emissao

#transformando a base de dados com o método melt
emissoes_gases.melt(id_vars = colunas_info, value_vars = colunas_emissao, var_name = 'Ano', value_name = 'Emissão')

#armazenando a nova tabela
emissoes_por_ano = emissoes_gases.melt(id_vars = colunas_info, value_vars = colunas_emissao, var_name = 'Ano', value_name = 'Emissão')

#agrupando os gases
emissoes_por_ano.groupby('Gás')

#obtendo as informações
emissoes_por_ano.groupby('Gás').groups

#acessando um grupo específico
emissoes_por_ano.groupby('Gás').get_group('CO2 (t)')

#ANÁLISE DOS GASES

#usando o método de agregação por soma
emissoes_por_ano.groupby('Gás').sum(numeric_only = True)
#emissoes_por_ano.groupby('Gás')[['Emissão']].sum() <outra forma

#reordenando os dados a partir dos valores
emissao_por_gas = emissoes_por_ano.groupby('Gás')[['Emissão']].sum().sort_values('Emissão', ascending = False)
emissao_por_gas

#fazendo um gráfico para melhorar a visualização
emissao_por_gas.plot(kind = 'barh', figsize = (10,6));

#obtendo a proporção dos valores
emissao_por_gas.iloc[0:9]#8 = posição dos valores na emissoes_por_gas

#calculando a porcentagem
print(f'A emissão de CO2 corresponde a {float((emissao_por_gas.iloc[0:9].sum()/emissao_por_gas.sum()).iloc[0])*100:.2f} % de emissão total de gases estufa no Brasil de 1970 a 2021.')

#encontrando a media de emissão em determinado ano
#emissoes_por_ano[emissoes_por_ano['Ano']==2021].groupby('Nível 1 - Setor')[['Emissão']].mean()

#03 - AGRUPAMENTO MULTI-INDEX

#descobrindo quais setores são mais poluentes por gás
gas_por_setor = emissoes_por_ano.groupby(['Gás', 'Nível 1 - Setor'])[['Emissão']].sum() #os dados serão agrupados tanto por gás quanto por setor
gas_por_setor

#identificando os setores mais poluentes
gas_por_setor.xs('CO2 (t)', level = 0) #xs: cross section

gas_por_setor.xs(('CO2 (t)', 'Mudança de Uso da Terra e Floresta'), level = [0,1]) #localizando a info co2 com level 0 e a mudança...no level 1

#descobrindo quais gases são mais poluentes por setor
#gas_por_setor.xs('CO2 (t)', level = 0).max()
gas_por_setor.xs('CO2 (t)', level = 0).idxmax()

#refinando o agrupamento
gas_por_setor.groupby(level = 0).idxmax()

#acrescentando a coluna com os valores
valores_max = gas_por_setor.groupby(level = 0).max().values

#unindo a tabela dos setores com os valores
tabela_sumarizada = gas_por_setor.groupby(level = 0).idxmax()
tabela_sumarizada.insert(1, 'Quantidade de emissão', valores_max)
tabela_sumarizada

#criando a tabela, encontrando os gases que mais emitem pra cada setor

#invertando as posições dos índices dos elvels
gas_por_setor.swaplevel(0,1)

#criando o df
gas_por_setor.swaplevel(0,1).groupby(level = 0).idxmax()

#criando uma visualização para entender a mudança ao longo dos anos
emissoes_por_ano

#agrupando com base na coluna ano
emissoes_por_ano.groupby('Ano')[['Emissão']].mean().plot(figsize = (10,6)); #mean = método de agregação para extrair médias

#extraindo o índice onde a emissão foi máxima
emissoes_por_ano.groupby('Ano')[['Emissão']].mean().idxmax()

#descobrindo a emissão média para cada um dos gases em uma tabela multi-index
emissoes_por_ano.groupby(['Ano', 'Gás'])[['Emissão']].mean()

#plotando um gráfico de linha para cada um dos gases
media_emissao_anual = emissoes_por_ano.groupby(['Ano', 'Gás'])[['Emissão']].mean().reset_index()
media_emissao_anual

media_emissao_anual = media_emissao_anual.pivot_table(index = 'Ano', columns = 'Gás', values = 'Emissão') #parametros: (indice,cols no df, parametros do df)
media_emissao_anual

media_emissao_anual.plot(subplots = True, figsize = (10,40)); #subplot: cria um gráfico pra cada coluna

#média da emissão dos setores por ano
emissao_setores = emissoes_por_ano.pivot_table(values = 'Emissão', index = 'Ano', columns = 'Nível 1 - Setor', aggfunc = 'mean')
emissao_setores

#plotando o gráfico
emissao_setores.plot(subplots = True, figsize = (10,10));

#04 - UNINDO DADOS

#importação do arquivo de dados
populacao_estados = pd.read_excel('/content/drive/MyDrive/Ciência de dados com Python - Alura/ciencia-de-dados-py/Pandas_03/POP2022_Municipios.xls', header = 1,skipfooter = 34) #removendo o cabeçalho e as ultimas linhas de texto
populacao_estados

#agrupando por estados
populacao_estados.groupby('UF').sum(numeric_only= True)

#buscando valores com texto na coluna
populacao_estados[populacao_estados['POPULAÇÃO'].str.contains('\(', na = False)]

#TRANSFORMANDO OS DADOS

#transformando os dados para remover os parenteses e os pontos, criando  novas colunas
populacao_estados = populacao_estados.assign(populacao_sem_parenteses = populacao_estados['POPULAÇÃO'].replace('\(\d{1,2}\)','', regex = True),
                                             populacao = lambda x: x.loc[:,'populacao_sem_parenteses'].replace('\.','', regex = True)) # (\d{1,2}\) = rejex do padrão textual,'' = substitouir por vazio

#checando a transormação
populacao_estados[populacao_estados['POPULAÇÃO'].str.contains('\(', na = False)]

#transformando a coluna populacao para valor inteiro
populacao_estados = populacao_estados.astype({'populacao':'int64'})

#agrupamentro da população
populacao_estados = populacao_estados.groupby('UF')[['populacao']].sum().reset_index()
populacao_estados

#REALIZANDO A JUNÇÃO DOS DADOS

emissao_estados = emissoes_por_ano[emissoes_por_ano['Ano'] == 2021].groupby('Estado')[['Emissão']].sum().reset_index() #agrupando por estados e somando
emissao_estados

#unindo as duas tabelas, usando o estado como chave

dados_agrupados = pd.merge(emissao_estados,populacao_estados, left_on = 'Estado', right_on = 'UF')
dados_agrupados

#verificando se há algum indicio de se a emissão aumenta conforme população
dados_agrupados.plot(x = 'populacao', y = 'Emissão', kind = 'scatter', figsize= (8,6));

#obtendo a informação de cada estado no ponto dos gráficos
import plotly.express as px

#criando o gráfico de dispersão novamente
px.scatter(data_frame = dados_agrupados, x = 'populacao', y = 'Emissão', text = 'Estado', opacity = 0)

#obtendo a emissão per capita, criando uma nova coluna
dados_agrupados = dados_agrupados.assign(emissao_per_capita = dados_agrupados['Emissão']/dados_agrupados['populacao']).sort_values('emissao_per_capita', ascending = False)
dados_agrupados

#criando uma visualização dessa informação
px.bar(data_frame = dados_agrupados, x = 'Estado', y = 'emissao_per_capita')

#melhorando a visualização do gráfico
px.scatter(data_frame = dados_agrupados, x = 'populacao', y = 'Emissão', text = 'Estado', size = 'emissao_per_capita')

